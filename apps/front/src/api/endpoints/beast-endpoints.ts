/**
 * Generated by otqs v1.0.0 üç∫
 * Do not edit manually.
 * @beast/server
 * OpenAPI spec version: 0.0.1
 */
import { createMutation, createQuery } from "@tanstack/solid-query";
import type {
  CreateQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  SolidMutationOptions,
  SolidQueryOptions,
} from "@tanstack/solid-query";
import type {
  AuthTokens,
  CreateLibrary,
  DeleteLibraryParams,
  EditLibraryPermissions,
  Episode,
  GetLibraryContentParams,
  GetLibraryParams,
  GetLibraryScanParams,
  GetLibraryShowFilesystemParams,
  GetMediaDetailParams,
  GetMediaParams,
  GetMovieParams,
  GetShowEpisodeParams,
  GetShowParams,
  GetShowSeasonParams,
  InitServerBody,
  Library,
  LibraryContent,
  LoginBody,
  Media,
  MediaWithStreams,
  Movie,
  PlayerSettings,
  PostLibraryNew201,
  PostPlayerEndParams,
  PostPlayerKeepaliveParams,
  PostShowScanParams,
  RefreshBody,
  RegisterBody,
  SeasonWithEpisodes,
  ShowWithSeasons,
  StartedPlayerInfos,
} from "../model";
import { customInstance } from "../../custom-axios-instance";
import type { ErrorType, BodyType } from "../../custom-axios-instance";

// eslint-disable-next-line
type SecondParameter<T extends (...args: any) => any> = T extends (
  config: any,
  args: infer P,
) => any
  ? P
  : never;

export const postAuthLogin = (
  loginBody: BodyType<LoginBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<AuthTokens>(
    {
      url: `http://localhost:3000/auth/login`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: loginBody,
    },
    options,
  );
};

export const getPostAuthLoginMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: SolidMutationOptions<
    Awaited<ReturnType<typeof postAuthLogin>>,
    TError,
    { data: BodyType<LoginBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postAuthLogin>>,
  TError,
  { data: BodyType<LoginBody> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthLogin>>,
    { data: BodyType<LoginBody> }
  > = (props) => {
    const { data } = props ?? {};

    return postAuthLogin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthLogin>>
>;
export type PostAuthLoginMutationBody = BodyType<LoginBody>;
export type PostAuthLoginMutationError = ErrorType<unknown>;

export const createPostAuthLogin = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: SolidMutationOptions<
      Awaited<ReturnType<typeof postAuthLogin>>,
      TError,
      { data: BodyType<LoginBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  return createMutation(() => {
    const opts = options?.();
    return getPostAuthLoginMutationOptions(opts);
  });
};

export const postAuthRefresh = (
  refreshBody: BodyType<RefreshBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<AuthTokens>(
    {
      url: `http://localhost:3000/auth/refresh`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: refreshBody,
    },
    options,
  );
};

export const getPostAuthRefreshMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: SolidMutationOptions<
    Awaited<ReturnType<typeof postAuthRefresh>>,
    TError,
    { data: BodyType<RefreshBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postAuthRefresh>>,
  TError,
  { data: BodyType<RefreshBody> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthRefresh>>,
    { data: BodyType<RefreshBody> }
  > = (props) => {
    const { data } = props ?? {};

    return postAuthRefresh(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthRefreshMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthRefresh>>
>;
export type PostAuthRefreshMutationBody = BodyType<RefreshBody>;
export type PostAuthRefreshMutationError = ErrorType<unknown>;

export const createPostAuthRefresh = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: SolidMutationOptions<
      Awaited<ReturnType<typeof postAuthRefresh>>,
      TError,
      { data: BodyType<RefreshBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  return createMutation(() => {
    const opts = options?.();
    return getPostAuthRefreshMutationOptions(opts);
  });
};

export const postAuthRegister = (
  registerBody: BodyType<RegisterBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<boolean>(
    {
      url: `http://localhost:3000/auth/register`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: registerBody,
    },
    options,
  );
};

export const getPostAuthRegisterMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: SolidMutationOptions<
    Awaited<ReturnType<typeof postAuthRegister>>,
    TError,
    { data: BodyType<RegisterBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postAuthRegister>>,
  TError,
  { data: BodyType<RegisterBody> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthRegister>>,
    { data: BodyType<RegisterBody> }
  > = (props) => {
    const { data } = props ?? {};

    return postAuthRegister(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthRegisterMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthRegister>>
>;
export type PostAuthRegisterMutationBody = BodyType<RegisterBody>;
export type PostAuthRegisterMutationError = ErrorType<unknown>;

export const createPostAuthRegister = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: SolidMutationOptions<
      Awaited<ReturnType<typeof postAuthRegister>>,
      TError,
      { data: BodyType<RegisterBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  return createMutation(() => {
    const opts = options?.();
    return getPostAuthRegisterMutationOptions(opts);
  });
};

/**
 * List all accessible libraries
 */
export const getLibraryAll = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Library[]>(
    { url: `http://localhost:3000/library/all`, method: "GET", signal },
    options,
  );
};

export const getGetLibraryAllQueryKey = () => {
  return [`http://localhost:3000/library/all`] as const;
};

export const getGetLibraryAllQueryOptions = <
  TData = Awaited<ReturnType<typeof getLibraryAll>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    SolidQueryOptions<Awaited<ReturnType<typeof getLibraryAll>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLibraryAllQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLibraryAll>>> = ({
    signal,
  }) => getLibraryAll(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as SolidQueryOptions<
    Awaited<ReturnType<typeof getLibraryAll>>,
    TError,
    TData
  > & { initialData?: undefined };
};

export type GetLibraryAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLibraryAll>>
>;
export type GetLibraryAllQueryError = ErrorType<unknown>;

export const createGetLibraryAll = <
  TData = Awaited<ReturnType<typeof getLibraryAll>>,
  TError = ErrorType<unknown>,
>(
  options?: () => {
    options?: {
      query?: Partial<
        SolidQueryOptions<
          Awaited<ReturnType<typeof getLibraryAll>>,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customInstance>;
    };
  },
): CreateQueryResult<TData, TError> => {
  const query = createQuery(() => {
    const opts = options?.() || {};
    return getGetLibraryAllQueryOptions(opts["options"]);
  }) as CreateQueryResult<TData, TError>;

  return query;
};

/**
 * create a new library
 */
export const postLibraryNew = (
  createLibrary: BodyType<CreateLibrary>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<PostLibraryNew201>(
    {
      url: `http://localhost:3000/library/new`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createLibrary,
    },
    options,
  );
};

export const getPostLibraryNewMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: SolidMutationOptions<
    Awaited<ReturnType<typeof postLibraryNew>>,
    TError,
    { data: BodyType<CreateLibrary> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postLibraryNew>>,
  TError,
  { data: BodyType<CreateLibrary> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postLibraryNew>>,
    { data: BodyType<CreateLibrary> }
  > = (props) => {
    const { data } = props ?? {};

    return postLibraryNew(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostLibraryNewMutationResult = NonNullable<
  Awaited<ReturnType<typeof postLibraryNew>>
>;
export type PostLibraryNewMutationBody = BodyType<CreateLibrary>;
export type PostLibraryNewMutationError = ErrorType<unknown>;

export const createPostLibraryNew = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: SolidMutationOptions<
      Awaited<ReturnType<typeof postLibraryNew>>,
      TError,
      { data: BodyType<CreateLibrary> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  return createMutation(() => {
    const opts = options?.();
    return getPostLibraryNewMutationOptions(opts);
  });
};

/**
 * delete a library
 */
export const deleteLibrary = (
  params: DeleteLibraryParams,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<boolean>(
    { url: `http://localhost:3000/library`, method: "DELETE", params },
    options,
  );
};

export const getDeleteLibraryMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: SolidMutationOptions<
    Awaited<ReturnType<typeof deleteLibrary>>,
    TError,
    { params: DeleteLibraryParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof deleteLibrary>>,
  TError,
  { params: DeleteLibraryParams },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteLibrary>>,
    { params: DeleteLibraryParams }
  > = (props) => {
    const { params } = props ?? {};

    return deleteLibrary(params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteLibraryMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteLibrary>>
>;

export type DeleteLibraryMutationError = ErrorType<unknown>;

export const createDeleteLibrary = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: SolidMutationOptions<
      Awaited<ReturnType<typeof deleteLibrary>>,
      TError,
      { params: DeleteLibraryParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  return createMutation(() => {
    const opts = options?.();
    return getDeleteLibraryMutationOptions(opts);
  });
};

/**
 * Get the Library data from its id
 */
export const getLibrary = (
  params: GetLibraryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Library>(
    { url: `http://localhost:3000/library`, method: "GET", params, signal },
    options,
  );
};

export const getGetLibraryQueryKey = (params: GetLibraryParams) => {
  return [
    `http://localhost:3000/library`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetLibraryQueryOptions = <
  TData = Awaited<ReturnType<typeof getLibrary>>,
  TError = ErrorType<unknown>,
>(
  params: GetLibraryParams,
  options?: {
    query?: Partial<
      SolidQueryOptions<Awaited<ReturnType<typeof getLibrary>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLibraryQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLibrary>>> = ({
    signal,
  }) => getLibrary(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as SolidQueryOptions<
    Awaited<ReturnType<typeof getLibrary>>,
    TError,
    TData
  > & { initialData?: undefined };
};

export type GetLibraryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLibrary>>
>;
export type GetLibraryQueryError = ErrorType<unknown>;

export const createGetLibrary = <
  TData = Awaited<ReturnType<typeof getLibrary>>,
  TError = ErrorType<unknown>,
>(
  options: () => {
    params: GetLibraryParams;
    options?: {
      query?: Partial<
        SolidQueryOptions<Awaited<ReturnType<typeof getLibrary>>, TError, TData>
      >;
      request?: SecondParameter<typeof customInstance>;
    };
  },
): CreateQueryResult<TData, TError> => {
  const query = createQuery(() => {
    const opts = options?.() || {};
    return getGetLibraryQueryOptions(opts["params"], opts["options"]);
  }) as CreateQueryResult<TData, TError>;

  return query;
};

export const postLibraryAccess = (
  editLibraryPermissions: BodyType<EditLibraryPermissions>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<boolean>(
    {
      url: `http://localhost:3000/library/access`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: editLibraryPermissions,
    },
    options,
  );
};

export const getPostLibraryAccessMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: SolidMutationOptions<
    Awaited<ReturnType<typeof postLibraryAccess>>,
    TError,
    { data: BodyType<EditLibraryPermissions> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postLibraryAccess>>,
  TError,
  { data: BodyType<EditLibraryPermissions> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postLibraryAccess>>,
    { data: BodyType<EditLibraryPermissions> }
  > = (props) => {
    const { data } = props ?? {};

    return postLibraryAccess(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostLibraryAccessMutationResult = NonNullable<
  Awaited<ReturnType<typeof postLibraryAccess>>
>;
export type PostLibraryAccessMutationBody = BodyType<EditLibraryPermissions>;
export type PostLibraryAccessMutationError = ErrorType<unknown>;

export const createPostLibraryAccess = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: SolidMutationOptions<
      Awaited<ReturnType<typeof postLibraryAccess>>,
      TError,
      { data: BodyType<EditLibraryPermissions> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  return createMutation(() => {
    const opts = options?.();
    return getPostLibraryAccessMutationOptions(opts);
  });
};

/**
 * Scan library, check and update missing metadatas or medias
 */
export const getLibraryScan = (
  params: GetLibraryScanParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    {
      url: `http://localhost:3000/library/scan`,
      method: "GET",
      params,
      signal,
    },
    options,
  );
};

export const getGetLibraryScanQueryKey = (params: GetLibraryScanParams) => {
  return [
    `http://localhost:3000/library/scan`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetLibraryScanQueryOptions = <
  TData = Awaited<ReturnType<typeof getLibraryScan>>,
  TError = ErrorType<unknown>,
>(
  params: GetLibraryScanParams,
  options?: {
    query?: Partial<
      SolidQueryOptions<
        Awaited<ReturnType<typeof getLibraryScan>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLibraryScanQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLibraryScan>>> = ({
    signal,
  }) => getLibraryScan(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as SolidQueryOptions<
    Awaited<ReturnType<typeof getLibraryScan>>,
    TError,
    TData
  > & { initialData?: undefined };
};

export type GetLibraryScanQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLibraryScan>>
>;
export type GetLibraryScanQueryError = ErrorType<unknown>;

export const createGetLibraryScan = <
  TData = Awaited<ReturnType<typeof getLibraryScan>>,
  TError = ErrorType<unknown>,
>(
  options: () => {
    params: GetLibraryScanParams;
    options?: {
      query?: Partial<
        SolidQueryOptions<
          Awaited<ReturnType<typeof getLibraryScan>>,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customInstance>;
    };
  },
): CreateQueryResult<TData, TError> => {
  const query = createQuery(() => {
    const opts = options?.() || {};
    return getGetLibraryScanQueryOptions(opts["params"], opts["options"]);
  }) as CreateQueryResult<TData, TError>;

  return query;
};

/**
 * Get the Library data from its id
 */
export const getLibraryContent = (
  params: GetLibraryContentParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<LibraryContent>(
    {
      url: `http://localhost:3000/library/content`,
      method: "GET",
      params,
      signal,
    },
    options,
  );
};

export const getGetLibraryContentQueryKey = (
  params: GetLibraryContentParams,
) => {
  return [
    `http://localhost:3000/library/content`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetLibraryContentQueryOptions = <
  TData = Awaited<ReturnType<typeof getLibraryContent>>,
  TError = ErrorType<unknown>,
>(
  params: GetLibraryContentParams,
  options?: {
    query?: Partial<
      SolidQueryOptions<
        Awaited<ReturnType<typeof getLibraryContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLibraryContentQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLibraryContent>>
  > = ({ signal }) => getLibraryContent(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as SolidQueryOptions<
    Awaited<ReturnType<typeof getLibraryContent>>,
    TError,
    TData
  > & { initialData?: undefined };
};

export type GetLibraryContentQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLibraryContent>>
>;
export type GetLibraryContentQueryError = ErrorType<unknown>;

export const createGetLibraryContent = <
  TData = Awaited<ReturnType<typeof getLibraryContent>>,
  TError = ErrorType<unknown>,
>(
  options: () => {
    params: GetLibraryContentParams;
    options?: {
      query?: Partial<
        SolidQueryOptions<
          Awaited<ReturnType<typeof getLibraryContent>>,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customInstance>;
    };
  },
): CreateQueryResult<TData, TError> => {
  const query = createQuery(() => {
    const opts = options?.() || {};
    return getGetLibraryContentQueryOptions(opts["params"], opts["options"]);
  }) as CreateQueryResult<TData, TError>;

  return query;
};

/**
 * Show filesystem

I do not like this endpoint, but i do not know any other way yet
 */
export const getLibraryShowFilesystem = (
  params: GetLibraryShowFilesystemParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<string[]>(
    {
      url: `http://localhost:3000/library/show-filesystem`,
      method: "GET",
      params,
      signal,
    },
    options,
  );
};

export const getGetLibraryShowFilesystemQueryKey = (
  params: GetLibraryShowFilesystemParams,
) => {
  return [
    `http://localhost:3000/library/show-filesystem`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetLibraryShowFilesystemQueryOptions = <
  TData = Awaited<ReturnType<typeof getLibraryShowFilesystem>>,
  TError = ErrorType<unknown>,
>(
  params: GetLibraryShowFilesystemParams,
  options?: {
    query?: Partial<
      SolidQueryOptions<
        Awaited<ReturnType<typeof getLibraryShowFilesystem>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLibraryShowFilesystemQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLibraryShowFilesystem>>
  > = ({ signal }) => getLibraryShowFilesystem(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as SolidQueryOptions<
    Awaited<ReturnType<typeof getLibraryShowFilesystem>>,
    TError,
    TData
  > & { initialData?: undefined };
};

export type GetLibraryShowFilesystemQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLibraryShowFilesystem>>
>;
export type GetLibraryShowFilesystemQueryError = ErrorType<unknown>;

export const createGetLibraryShowFilesystem = <
  TData = Awaited<ReturnType<typeof getLibraryShowFilesystem>>,
  TError = ErrorType<unknown>,
>(
  options: () => {
    params: GetLibraryShowFilesystemParams;
    options?: {
      query?: Partial<
        SolidQueryOptions<
          Awaited<ReturnType<typeof getLibraryShowFilesystem>>,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customInstance>;
    };
  },
): CreateQueryResult<TData, TError> => {
  const query = createQuery(() => {
    const opts = options?.() || {};
    return getGetLibraryShowFilesystemQueryOptions(
      opts["params"],
      opts["options"],
    );
  }) as CreateQueryResult<TData, TError>;

  return query;
};

/**
 * Get a media from its id
 */
export const getMedia = (
  params: GetMediaParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Media>(
    { url: `http://localhost:3000/media`, method: "GET", params, signal },
    options,
  );
};

export const getGetMediaQueryKey = (params: GetMediaParams) => {
  return [`http://localhost:3000/media`, ...(params ? [params] : [])] as const;
};

export const getGetMediaQueryOptions = <
  TData = Awaited<ReturnType<typeof getMedia>>,
  TError = ErrorType<unknown>,
>(
  params: GetMediaParams,
  options?: {
    query?: Partial<
      SolidQueryOptions<Awaited<ReturnType<typeof getMedia>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMediaQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMedia>>> = ({
    signal,
  }) => getMedia(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as SolidQueryOptions<
    Awaited<ReturnType<typeof getMedia>>,
    TError,
    TData
  > & { initialData?: undefined };
};

export type GetMediaQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMedia>>
>;
export type GetMediaQueryError = ErrorType<unknown>;

export const createGetMedia = <
  TData = Awaited<ReturnType<typeof getMedia>>,
  TError = ErrorType<unknown>,
>(
  options: () => {
    params: GetMediaParams;
    options?: {
      query?: Partial<
        SolidQueryOptions<Awaited<ReturnType<typeof getMedia>>, TError, TData>
      >;
      request?: SecondParameter<typeof customInstance>;
    };
  },
): CreateQueryResult<TData, TError> => {
  const query = createQuery(() => {
    const opts = options?.() || {};
    return getGetMediaQueryOptions(opts["params"], opts["options"]);
  }) as CreateQueryResult<TData, TError>;

  return query;
};

/**
 * Get a media details from its id
 */
export const getMediaDetail = (
  params: GetMediaDetailParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<MediaWithStreams>(
    {
      url: `http://localhost:3000/media/detail`,
      method: "GET",
      params,
      signal,
    },
    options,
  );
};

export const getGetMediaDetailQueryKey = (params: GetMediaDetailParams) => {
  return [
    `http://localhost:3000/media/detail`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetMediaDetailQueryOptions = <
  TData = Awaited<ReturnType<typeof getMediaDetail>>,
  TError = ErrorType<unknown>,
>(
  params: GetMediaDetailParams,
  options?: {
    query?: Partial<
      SolidQueryOptions<
        Awaited<ReturnType<typeof getMediaDetail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMediaDetailQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMediaDetail>>> = ({
    signal,
  }) => getMediaDetail(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as SolidQueryOptions<
    Awaited<ReturnType<typeof getMediaDetail>>,
    TError,
    TData
  > & { initialData?: undefined };
};

export type GetMediaDetailQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMediaDetail>>
>;
export type GetMediaDetailQueryError = ErrorType<unknown>;

export const createGetMediaDetail = <
  TData = Awaited<ReturnType<typeof getMediaDetail>>,
  TError = ErrorType<unknown>,
>(
  options: () => {
    params: GetMediaDetailParams;
    options?: {
      query?: Partial<
        SolidQueryOptions<
          Awaited<ReturnType<typeof getMediaDetail>>,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customInstance>;
    };
  },
): CreateQueryResult<TData, TError> => {
  const query = createQuery(() => {
    const opts = options?.() || {};
    return getGetMediaDetailQueryOptions(opts["params"], opts["options"]);
  }) as CreateQueryResult<TData, TError>;

  return query;
};

/**
 * Get the informations of a movie
 */
export const getMovie = (
  params: GetMovieParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Movie>(
    { url: `http://localhost:3000/movie`, method: "GET", params, signal },
    options,
  );
};

export const getGetMovieQueryKey = (params: GetMovieParams) => {
  return [`http://localhost:3000/movie`, ...(params ? [params] : [])] as const;
};

export const getGetMovieQueryOptions = <
  TData = Awaited<ReturnType<typeof getMovie>>,
  TError = ErrorType<unknown>,
>(
  params: GetMovieParams,
  options?: {
    query?: Partial<
      SolidQueryOptions<Awaited<ReturnType<typeof getMovie>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMovieQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMovie>>> = ({
    signal,
  }) => getMovie(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as SolidQueryOptions<
    Awaited<ReturnType<typeof getMovie>>,
    TError,
    TData
  > & { initialData?: undefined };
};

export type GetMovieQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMovie>>
>;
export type GetMovieQueryError = ErrorType<unknown>;

export const createGetMovie = <
  TData = Awaited<ReturnType<typeof getMovie>>,
  TError = ErrorType<unknown>,
>(
  options: () => {
    params: GetMovieParams;
    options?: {
      query?: Partial<
        SolidQueryOptions<Awaited<ReturnType<typeof getMovie>>, TError, TData>
      >;
      request?: SecondParameter<typeof customInstance>;
    };
  },
): CreateQueryResult<TData, TError> => {
  const query = createQuery(() => {
    const opts = options?.() || {};
    return getGetMovieQueryOptions(opts["params"], opts["options"]);
  }) as CreateQueryResult<TData, TError>;

  return query;
};

export const postPlayerStart = (
  playerSettings: BodyType<PlayerSettings>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<StartedPlayerInfos>(
    {
      url: `http://localhost:3000/player/start`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: playerSettings,
    },
    options,
  );
};

export const getPostPlayerStartMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: SolidMutationOptions<
    Awaited<ReturnType<typeof postPlayerStart>>,
    TError,
    { data: BodyType<PlayerSettings> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postPlayerStart>>,
  TError,
  { data: BodyType<PlayerSettings> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postPlayerStart>>,
    { data: BodyType<PlayerSettings> }
  > = (props) => {
    const { data } = props ?? {};

    return postPlayerStart(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostPlayerStartMutationResult = NonNullable<
  Awaited<ReturnType<typeof postPlayerStart>>
>;
export type PostPlayerStartMutationBody = BodyType<PlayerSettings>;
export type PostPlayerStartMutationError = ErrorType<unknown>;

export const createPostPlayerStart = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: SolidMutationOptions<
      Awaited<ReturnType<typeof postPlayerStart>>,
      TError,
      { data: BodyType<PlayerSettings> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  return createMutation(() => {
    const opts = options?.();
    return getPostPlayerStartMutationOptions(opts);
  });
};

/**
 * Used to tell the server that the user is still watching
if the server does not receive this call within a 10s window,
the server will close the player to save ressources
 */
export const postPlayerKeepalive = (
  params: PostPlayerKeepaliveParams,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<boolean>(
    { url: `http://localhost:3000/player/keepalive`, method: "POST", params },
    options,
  );
};

export const getPostPlayerKeepaliveMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: SolidMutationOptions<
    Awaited<ReturnType<typeof postPlayerKeepalive>>,
    TError,
    { params: PostPlayerKeepaliveParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postPlayerKeepalive>>,
  TError,
  { params: PostPlayerKeepaliveParams },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postPlayerKeepalive>>,
    { params: PostPlayerKeepaliveParams }
  > = (props) => {
    const { params } = props ?? {};

    return postPlayerKeepalive(params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostPlayerKeepaliveMutationResult = NonNullable<
  Awaited<ReturnType<typeof postPlayerKeepalive>>
>;

export type PostPlayerKeepaliveMutationError = ErrorType<unknown>;

export const createPostPlayerKeepalive = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: SolidMutationOptions<
      Awaited<ReturnType<typeof postPlayerKeepalive>>,
      TError,
      { params: PostPlayerKeepaliveParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  return createMutation(() => {
    const opts = options?.();
    return getPostPlayerKeepaliveMutationOptions(opts);
  });
};

export const postPlayerEnd = (
  params: PostPlayerEndParams,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<void>(
    { url: `http://localhost:3000/player/end`, method: "POST", params },
    options,
  );
};

export const getPostPlayerEndMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: SolidMutationOptions<
    Awaited<ReturnType<typeof postPlayerEnd>>,
    TError,
    { params: PostPlayerEndParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postPlayerEnd>>,
  TError,
  { params: PostPlayerEndParams },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postPlayerEnd>>,
    { params: PostPlayerEndParams }
  > = (props) => {
    const { params } = props ?? {};

    return postPlayerEnd(params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostPlayerEndMutationResult = NonNullable<
  Awaited<ReturnType<typeof postPlayerEnd>>
>;

export type PostPlayerEndMutationError = ErrorType<unknown>;

export const createPostPlayerEnd = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: SolidMutationOptions<
      Awaited<ReturnType<typeof postPlayerEnd>>,
      TError,
      { params: PostPlayerEndParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  return createMutation(() => {
    const opts = options?.();
    return getPostPlayerEndMutationOptions(opts);
  });
};

/**
 * Save the minimum required informations to use this server
 */
export const postSettingsInit = (
  initServerBody: BodyType<InitServerBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<void>(
    {
      url: `http://localhost:3000/settings/init`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: initServerBody,
    },
    options,
  );
};

export const getPostSettingsInitMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: SolidMutationOptions<
    Awaited<ReturnType<typeof postSettingsInit>>,
    TError,
    { data: BodyType<InitServerBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postSettingsInit>>,
  TError,
  { data: BodyType<InitServerBody> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postSettingsInit>>,
    { data: BodyType<InitServerBody> }
  > = (props) => {
    const { data } = props ?? {};

    return postSettingsInit(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostSettingsInitMutationResult = NonNullable<
  Awaited<ReturnType<typeof postSettingsInit>>
>;
export type PostSettingsInitMutationBody = BodyType<InitServerBody>;
export type PostSettingsInitMutationError = ErrorType<unknown>;

export const createPostSettingsInit = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: SolidMutationOptions<
      Awaited<ReturnType<typeof postSettingsInit>>,
      TError,
      { data: BodyType<InitServerBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  return createMutation(() => {
    const opts = options?.();
    return getPostSettingsInitMutationOptions(opts);
  });
};

/**
 * Is the current server initialized
 */
export const getSettingsInitialized = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    {
      url: `http://localhost:3000/settings/initialized`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetSettingsInitializedQueryKey = () => {
  return [`http://localhost:3000/settings/initialized`] as const;
};

export const getGetSettingsInitializedQueryOptions = <
  TData = Awaited<ReturnType<typeof getSettingsInitialized>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    SolidQueryOptions<
      Awaited<ReturnType<typeof getSettingsInitialized>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSettingsInitializedQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSettingsInitialized>>
  > = ({ signal }) => getSettingsInitialized(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as SolidQueryOptions<
    Awaited<ReturnType<typeof getSettingsInitialized>>,
    TError,
    TData
  > & { initialData?: undefined };
};

export type GetSettingsInitializedQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSettingsInitialized>>
>;
export type GetSettingsInitializedQueryError = ErrorType<unknown>;

export const createGetSettingsInitialized = <
  TData = Awaited<ReturnType<typeof getSettingsInitialized>>,
  TError = ErrorType<unknown>,
>(
  options?: () => {
    options?: {
      query?: Partial<
        SolidQueryOptions<
          Awaited<ReturnType<typeof getSettingsInitialized>>,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customInstance>;
    };
  },
): CreateQueryResult<TData, TError> => {
  const query = createQuery(() => {
    const opts = options?.() || {};
    return getGetSettingsInitializedQueryOptions(opts["options"]);
  }) as CreateQueryResult<TData, TError>;

  return query;
};

/**
 * Get the informations of a show
 */
export const getShow = (
  params: GetShowParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ShowWithSeasons>(
    { url: `http://localhost:3000/show`, method: "GET", params, signal },
    options,
  );
};

export const getGetShowQueryKey = (params: GetShowParams) => {
  return [`http://localhost:3000/show`, ...(params ? [params] : [])] as const;
};

export const getGetShowQueryOptions = <
  TData = Awaited<ReturnType<typeof getShow>>,
  TError = ErrorType<unknown>,
>(
  params: GetShowParams,
  options?: {
    query?: Partial<
      SolidQueryOptions<Awaited<ReturnType<typeof getShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetShowQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getShow>>> = ({
    signal,
  }) => getShow(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as SolidQueryOptions<
    Awaited<ReturnType<typeof getShow>>,
    TError,
    TData
  > & { initialData?: undefined };
};

export type GetShowQueryResult = NonNullable<
  Awaited<ReturnType<typeof getShow>>
>;
export type GetShowQueryError = ErrorType<unknown>;

export const createGetShow = <
  TData = Awaited<ReturnType<typeof getShow>>,
  TError = ErrorType<unknown>,
>(
  options: () => {
    params: GetShowParams;
    options?: {
      query?: Partial<
        SolidQueryOptions<Awaited<ReturnType<typeof getShow>>, TError, TData>
      >;
      request?: SecondParameter<typeof customInstance>;
    };
  },
): CreateQueryResult<TData, TError> => {
  const query = createQuery(() => {
    const opts = options?.() || {};
    return getGetShowQueryOptions(opts["params"], opts["options"]);
  }) as CreateQueryResult<TData, TError>;

  return query;
};

/**
 * Start a scan on a show
 */
export const postShowScan = (
  params: PostShowScanParams,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<boolean>(
    { url: `http://localhost:3000/show/scan`, method: "POST", params },
    options,
  );
};

export const getPostShowScanMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: SolidMutationOptions<
    Awaited<ReturnType<typeof postShowScan>>,
    TError,
    { params: PostShowScanParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postShowScan>>,
  TError,
  { params: PostShowScanParams },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postShowScan>>,
    { params: PostShowScanParams }
  > = (props) => {
    const { params } = props ?? {};

    return postShowScan(params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostShowScanMutationResult = NonNullable<
  Awaited<ReturnType<typeof postShowScan>>
>;

export type PostShowScanMutationError = ErrorType<unknown>;

export const createPostShowScan = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: SolidMutationOptions<
      Awaited<ReturnType<typeof postShowScan>>,
      TError,
      { params: PostShowScanParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  return createMutation(() => {
    const opts = options?.();
    return getPostShowScanMutationOptions(opts);
  });
};

/**
 * Get the informations of a season
 */
export const getShowSeason = (
  params: GetShowSeasonParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<SeasonWithEpisodes>(
    { url: `http://localhost:3000/show/season`, method: "GET", params, signal },
    options,
  );
};

export const getGetShowSeasonQueryKey = (params: GetShowSeasonParams) => {
  return [
    `http://localhost:3000/show/season`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetShowSeasonQueryOptions = <
  TData = Awaited<ReturnType<typeof getShowSeason>>,
  TError = ErrorType<unknown>,
>(
  params: GetShowSeasonParams,
  options?: {
    query?: Partial<
      SolidQueryOptions<
        Awaited<ReturnType<typeof getShowSeason>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetShowSeasonQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getShowSeason>>> = ({
    signal,
  }) => getShowSeason(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as SolidQueryOptions<
    Awaited<ReturnType<typeof getShowSeason>>,
    TError,
    TData
  > & { initialData?: undefined };
};

export type GetShowSeasonQueryResult = NonNullable<
  Awaited<ReturnType<typeof getShowSeason>>
>;
export type GetShowSeasonQueryError = ErrorType<unknown>;

export const createGetShowSeason = <
  TData = Awaited<ReturnType<typeof getShowSeason>>,
  TError = ErrorType<unknown>,
>(
  options: () => {
    params: GetShowSeasonParams;
    options?: {
      query?: Partial<
        SolidQueryOptions<
          Awaited<ReturnType<typeof getShowSeason>>,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customInstance>;
    };
  },
): CreateQueryResult<TData, TError> => {
  const query = createQuery(() => {
    const opts = options?.() || {};
    return getGetShowSeasonQueryOptions(opts["params"], opts["options"]);
  }) as CreateQueryResult<TData, TError>;

  return query;
};

/**
 * Get the informations of a episode
 */
export const getShowEpisode = (
  params: GetShowEpisodeParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Episode>(
    {
      url: `http://localhost:3000/show/episode`,
      method: "GET",
      params,
      signal,
    },
    options,
  );
};

export const getGetShowEpisodeQueryKey = (params: GetShowEpisodeParams) => {
  return [
    `http://localhost:3000/show/episode`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetShowEpisodeQueryOptions = <
  TData = Awaited<ReturnType<typeof getShowEpisode>>,
  TError = ErrorType<unknown>,
>(
  params: GetShowEpisodeParams,
  options?: {
    query?: Partial<
      SolidQueryOptions<
        Awaited<ReturnType<typeof getShowEpisode>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetShowEpisodeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getShowEpisode>>> = ({
    signal,
  }) => getShowEpisode(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as SolidQueryOptions<
    Awaited<ReturnType<typeof getShowEpisode>>,
    TError,
    TData
  > & { initialData?: undefined };
};

export type GetShowEpisodeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getShowEpisode>>
>;
export type GetShowEpisodeQueryError = ErrorType<unknown>;

export const createGetShowEpisode = <
  TData = Awaited<ReturnType<typeof getShowEpisode>>,
  TError = ErrorType<unknown>,
>(
  options: () => {
    params: GetShowEpisodeParams;
    options?: {
      query?: Partial<
        SolidQueryOptions<
          Awaited<ReturnType<typeof getShowEpisode>>,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customInstance>;
    };
  },
): CreateQueryResult<TData, TError> => {
  const query = createQuery(() => {
    const opts = options?.() || {};
    return getGetShowEpisodeQueryOptions(opts["params"], opts["options"]);
  }) as CreateQueryResult<TData, TError>;

  return query;
};
