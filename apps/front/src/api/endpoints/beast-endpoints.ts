/**
 * Generated by otqs v1.0.0 üç∫
 * Do not edit manually.
 * @beast/backend
 * OpenAPI spec version: 0.0.1
 */
import { createMutation, createQuery } from "@tanstack/solid-query";
import type {
  CreateQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  SolidMutationOptions,
  SolidQueryOptions,
} from "@tanstack/solid-query";
import type {
  AuthTokens,
  CreateLibraryDTO,
  EpisodeDTO,
  GetLibraryAll200Item,
  GetLibraryContentParams,
  GetLibraryParams,
  GetLibraryScanParams,
  GetShowEpisodeParams,
  GetShowParams,
  GetShowSeasonParams,
  LibraryContent,
  LibraryDTO,
  LoginBody,
  PlayerSettings,
  PostPlayerEndParams,
  RefreshBody,
  RegisterBody,
  SeasonWithEpisodes,
  ShowWithSeasons,
  StartedPlayerInfos,
} from "../model";
import { customInstance } from "../../custom-axios-instance";
import type { ErrorType, BodyType } from "../../custom-axios-instance";

// eslint-disable-next-line
type SecondParameter<T extends (...args: any) => any> = T extends (
  config: any,
  args: infer P,
) => any
  ? P
  : never;

export const postAuthLogin = (
  loginBody: BodyType<LoginBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<AuthTokens>(
    {
      url: `http://localhost:3000/auth/login`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: loginBody,
    },
    options,
  );
};

export const getPostAuthLoginMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: SolidMutationOptions<
    Awaited<ReturnType<typeof postAuthLogin>>,
    TError,
    { data: BodyType<LoginBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postAuthLogin>>,
  TError,
  { data: BodyType<LoginBody> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthLogin>>,
    { data: BodyType<LoginBody> }
  > = (props) => {
    const { data } = props ?? {};

    return postAuthLogin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthLogin>>
>;
export type PostAuthLoginMutationBody = BodyType<LoginBody>;
export type PostAuthLoginMutationError = ErrorType<unknown>;

export const createPostAuthLogin = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: SolidMutationOptions<
      Awaited<ReturnType<typeof postAuthLogin>>,
      TError,
      { data: BodyType<LoginBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  return createMutation(() => {
    const opts = options?.();
    return getPostAuthLoginMutationOptions(opts);
  });
};

export const postAuthRefresh = (
  refreshBody: BodyType<RefreshBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<AuthTokens>(
    {
      url: `http://localhost:3000/auth/refresh`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: refreshBody,
    },
    options,
  );
};

export const getPostAuthRefreshMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: SolidMutationOptions<
    Awaited<ReturnType<typeof postAuthRefresh>>,
    TError,
    { data: BodyType<RefreshBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postAuthRefresh>>,
  TError,
  { data: BodyType<RefreshBody> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthRefresh>>,
    { data: BodyType<RefreshBody> }
  > = (props) => {
    const { data } = props ?? {};

    return postAuthRefresh(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthRefreshMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthRefresh>>
>;
export type PostAuthRefreshMutationBody = BodyType<RefreshBody>;
export type PostAuthRefreshMutationError = ErrorType<unknown>;

export const createPostAuthRefresh = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: SolidMutationOptions<
      Awaited<ReturnType<typeof postAuthRefresh>>,
      TError,
      { data: BodyType<RefreshBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  return createMutation(() => {
    const opts = options?.();
    return getPostAuthRefreshMutationOptions(opts);
  });
};

export const postAuthRegister = (
  registerBody: BodyType<RegisterBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<boolean>(
    {
      url: `http://localhost:3000/auth/register`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: registerBody,
    },
    options,
  );
};

export const getPostAuthRegisterMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: SolidMutationOptions<
    Awaited<ReturnType<typeof postAuthRegister>>,
    TError,
    { data: BodyType<RegisterBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postAuthRegister>>,
  TError,
  { data: BodyType<RegisterBody> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthRegister>>,
    { data: BodyType<RegisterBody> }
  > = (props) => {
    const { data } = props ?? {};

    return postAuthRegister(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthRegisterMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthRegister>>
>;
export type PostAuthRegisterMutationBody = BodyType<RegisterBody>;
export type PostAuthRegisterMutationError = ErrorType<unknown>;

export const createPostAuthRegister = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: SolidMutationOptions<
      Awaited<ReturnType<typeof postAuthRegister>>,
      TError,
      { data: BodyType<RegisterBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  return createMutation(() => {
    const opts = options?.();
    return getPostAuthRegisterMutationOptions(opts);
  });
};

/**
 * List all libraries
 */
export const getLibraryAll = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetLibraryAll200Item[]>(
    { url: `http://localhost:3000/library/all`, method: "GET", signal },
    options,
  );
};

export const getGetLibraryAllQueryKey = () => {
  return [`http://localhost:3000/library/all`] as const;
};

export const getGetLibraryAllQueryOptions = <
  TData = Awaited<ReturnType<typeof getLibraryAll>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    SolidQueryOptions<Awaited<ReturnType<typeof getLibraryAll>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLibraryAllQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLibraryAll>>> = ({
    signal,
  }) => getLibraryAll(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as SolidQueryOptions<
    Awaited<ReturnType<typeof getLibraryAll>>,
    TError,
    TData
  > & { initialData?: undefined };
};

export type GetLibraryAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLibraryAll>>
>;
export type GetLibraryAllQueryError = ErrorType<unknown>;

export const createGetLibraryAll = <
  TData = Awaited<ReturnType<typeof getLibraryAll>>,
  TError = ErrorType<unknown>,
>(
  options?: () => {
    options?: {
      query?: Partial<
        SolidQueryOptions<
          Awaited<ReturnType<typeof getLibraryAll>>,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customInstance>;
    };
  },
): CreateQueryResult<TData, TError> => {
  const query = createQuery(() => {
    const opts = options?.() || {};
    return getGetLibraryAllQueryOptions(opts["options"]);
  }) as CreateQueryResult<TData, TError>;

  return query;
};

/**
 * Create a new library and start scanning it
 */
export const postLibraryNew = (
  createLibraryDTO: BodyType<CreateLibraryDTO>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<boolean>(
    {
      url: `http://localhost:3000/library/new`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createLibraryDTO,
    },
    options,
  );
};

export const getPostLibraryNewMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: SolidMutationOptions<
    Awaited<ReturnType<typeof postLibraryNew>>,
    TError,
    { data: BodyType<CreateLibraryDTO> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postLibraryNew>>,
  TError,
  { data: BodyType<CreateLibraryDTO> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postLibraryNew>>,
    { data: BodyType<CreateLibraryDTO> }
  > = (props) => {
    const { data } = props ?? {};

    return postLibraryNew(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostLibraryNewMutationResult = NonNullable<
  Awaited<ReturnType<typeof postLibraryNew>>
>;
export type PostLibraryNewMutationBody = BodyType<CreateLibraryDTO>;
export type PostLibraryNewMutationError = ErrorType<unknown>;

export const createPostLibraryNew = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: SolidMutationOptions<
      Awaited<ReturnType<typeof postLibraryNew>>,
      TError,
      { data: BodyType<CreateLibraryDTO> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  return createMutation(() => {
    const opts = options?.();
    return getPostLibraryNewMutationOptions(opts);
  });
};

/**
 * Scan library, check and update missing metadatas or medias
 */
export const getLibraryScan = (
  params: GetLibraryScanParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    {
      url: `http://localhost:3000/library/scan`,
      method: "GET",
      params,
      signal,
    },
    options,
  );
};

export const getGetLibraryScanQueryKey = (params: GetLibraryScanParams) => {
  return [
    `http://localhost:3000/library/scan`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetLibraryScanQueryOptions = <
  TData = Awaited<ReturnType<typeof getLibraryScan>>,
  TError = ErrorType<unknown>,
>(
  params: GetLibraryScanParams,
  options?: {
    query?: Partial<
      SolidQueryOptions<
        Awaited<ReturnType<typeof getLibraryScan>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLibraryScanQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLibraryScan>>> = ({
    signal,
  }) => getLibraryScan(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as SolidQueryOptions<
    Awaited<ReturnType<typeof getLibraryScan>>,
    TError,
    TData
  > & { initialData?: undefined };
};

export type GetLibraryScanQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLibraryScan>>
>;
export type GetLibraryScanQueryError = ErrorType<unknown>;

export const createGetLibraryScan = <
  TData = Awaited<ReturnType<typeof getLibraryScan>>,
  TError = ErrorType<unknown>,
>(
  options: () => {
    params: GetLibraryScanParams;
    options?: {
      query?: Partial<
        SolidQueryOptions<
          Awaited<ReturnType<typeof getLibraryScan>>,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customInstance>;
    };
  },
): CreateQueryResult<TData, TError> => {
  const query = createQuery(() => {
    const opts = options?.() || {};
    return getGetLibraryScanQueryOptions(opts["params"], opts["options"]);
  }) as CreateQueryResult<TData, TError>;

  return query;
};

/**
 * Get the Library data from its id
 */
export const getLibrary = (
  params: GetLibraryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<LibraryDTO>(
    { url: `http://localhost:3000/library`, method: "GET", params, signal },
    options,
  );
};

export const getGetLibraryQueryKey = (params: GetLibraryParams) => {
  return [
    `http://localhost:3000/library`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetLibraryQueryOptions = <
  TData = Awaited<ReturnType<typeof getLibrary>>,
  TError = ErrorType<unknown>,
>(
  params: GetLibraryParams,
  options?: {
    query?: Partial<
      SolidQueryOptions<Awaited<ReturnType<typeof getLibrary>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLibraryQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLibrary>>> = ({
    signal,
  }) => getLibrary(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as SolidQueryOptions<
    Awaited<ReturnType<typeof getLibrary>>,
    TError,
    TData
  > & { initialData?: undefined };
};

export type GetLibraryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLibrary>>
>;
export type GetLibraryQueryError = ErrorType<unknown>;

export const createGetLibrary = <
  TData = Awaited<ReturnType<typeof getLibrary>>,
  TError = ErrorType<unknown>,
>(
  options: () => {
    params: GetLibraryParams;
    options?: {
      query?: Partial<
        SolidQueryOptions<Awaited<ReturnType<typeof getLibrary>>, TError, TData>
      >;
      request?: SecondParameter<typeof customInstance>;
    };
  },
): CreateQueryResult<TData, TError> => {
  const query = createQuery(() => {
    const opts = options?.() || {};
    return getGetLibraryQueryOptions(opts["params"], opts["options"]);
  }) as CreateQueryResult<TData, TError>;

  return query;
};

/**
 * Get the Library data from its id
 */
export const getLibraryContent = (
  params: GetLibraryContentParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<LibraryContent>(
    {
      url: `http://localhost:3000/library/content`,
      method: "GET",
      params,
      signal,
    },
    options,
  );
};

export const getGetLibraryContentQueryKey = (
  params: GetLibraryContentParams,
) => {
  return [
    `http://localhost:3000/library/content`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetLibraryContentQueryOptions = <
  TData = Awaited<ReturnType<typeof getLibraryContent>>,
  TError = ErrorType<unknown>,
>(
  params: GetLibraryContentParams,
  options?: {
    query?: Partial<
      SolidQueryOptions<
        Awaited<ReturnType<typeof getLibraryContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLibraryContentQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLibraryContent>>
  > = ({ signal }) => getLibraryContent(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as SolidQueryOptions<
    Awaited<ReturnType<typeof getLibraryContent>>,
    TError,
    TData
  > & { initialData?: undefined };
};

export type GetLibraryContentQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLibraryContent>>
>;
export type GetLibraryContentQueryError = ErrorType<unknown>;

export const createGetLibraryContent = <
  TData = Awaited<ReturnType<typeof getLibraryContent>>,
  TError = ErrorType<unknown>,
>(
  options: () => {
    params: GetLibraryContentParams;
    options?: {
      query?: Partial<
        SolidQueryOptions<
          Awaited<ReturnType<typeof getLibraryContent>>,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customInstance>;
    };
  },
): CreateQueryResult<TData, TError> => {
  const query = createQuery(() => {
    const opts = options?.() || {};
    return getGetLibraryContentQueryOptions(opts["params"], opts["options"]);
  }) as CreateQueryResult<TData, TError>;

  return query;
};

export const postPlayerStart = (
  playerSettings: BodyType<PlayerSettings>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<StartedPlayerInfos>(
    {
      url: `http://localhost:3000/player/start`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: playerSettings,
    },
    options,
  );
};

export const getPostPlayerStartMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: SolidMutationOptions<
    Awaited<ReturnType<typeof postPlayerStart>>,
    TError,
    { data: BodyType<PlayerSettings> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postPlayerStart>>,
  TError,
  { data: BodyType<PlayerSettings> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postPlayerStart>>,
    { data: BodyType<PlayerSettings> }
  > = (props) => {
    const { data } = props ?? {};

    return postPlayerStart(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostPlayerStartMutationResult = NonNullable<
  Awaited<ReturnType<typeof postPlayerStart>>
>;
export type PostPlayerStartMutationBody = BodyType<PlayerSettings>;
export type PostPlayerStartMutationError = ErrorType<unknown>;

export const createPostPlayerStart = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: SolidMutationOptions<
      Awaited<ReturnType<typeof postPlayerStart>>,
      TError,
      { data: BodyType<PlayerSettings> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  return createMutation(() => {
    const opts = options?.();
    return getPostPlayerStartMutationOptions(opts);
  });
};

export const postPlayerEnd = (
  params: PostPlayerEndParams,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<void>(
    { url: `http://localhost:3000/player/end`, method: "POST", params },
    options,
  );
};

export const getPostPlayerEndMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: SolidMutationOptions<
    Awaited<ReturnType<typeof postPlayerEnd>>,
    TError,
    { params: PostPlayerEndParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postPlayerEnd>>,
  TError,
  { params: PostPlayerEndParams },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postPlayerEnd>>,
    { params: PostPlayerEndParams }
  > = (props) => {
    const { params } = props ?? {};

    return postPlayerEnd(params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostPlayerEndMutationResult = NonNullable<
  Awaited<ReturnType<typeof postPlayerEnd>>
>;

export type PostPlayerEndMutationError = ErrorType<unknown>;

export const createPostPlayerEnd = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: SolidMutationOptions<
      Awaited<ReturnType<typeof postPlayerEnd>>,
      TError,
      { params: PostPlayerEndParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  return createMutation(() => {
    const opts = options?.();
    return getPostPlayerEndMutationOptions(opts);
  });
};

/**
 * Get the informations of a show
 */
export const getShow = (
  params: GetShowParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ShowWithSeasons>(
    { url: `http://localhost:3000/show`, method: "GET", params, signal },
    options,
  );
};

export const getGetShowQueryKey = (params: GetShowParams) => {
  return [`http://localhost:3000/show`, ...(params ? [params] : [])] as const;
};

export const getGetShowQueryOptions = <
  TData = Awaited<ReturnType<typeof getShow>>,
  TError = ErrorType<unknown>,
>(
  params: GetShowParams,
  options?: {
    query?: Partial<
      SolidQueryOptions<Awaited<ReturnType<typeof getShow>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetShowQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getShow>>> = ({
    signal,
  }) => getShow(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as SolidQueryOptions<
    Awaited<ReturnType<typeof getShow>>,
    TError,
    TData
  > & { initialData?: undefined };
};

export type GetShowQueryResult = NonNullable<
  Awaited<ReturnType<typeof getShow>>
>;
export type GetShowQueryError = ErrorType<unknown>;

export const createGetShow = <
  TData = Awaited<ReturnType<typeof getShow>>,
  TError = ErrorType<unknown>,
>(
  options: () => {
    params: GetShowParams;
    options?: {
      query?: Partial<
        SolidQueryOptions<Awaited<ReturnType<typeof getShow>>, TError, TData>
      >;
      request?: SecondParameter<typeof customInstance>;
    };
  },
): CreateQueryResult<TData, TError> => {
  const query = createQuery(() => {
    const opts = options?.() || {};
    return getGetShowQueryOptions(opts["params"], opts["options"]);
  }) as CreateQueryResult<TData, TError>;

  return query;
};

/**
 * Get the informations of a season
 */
export const getShowSeason = (
  params: GetShowSeasonParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<SeasonWithEpisodes>(
    { url: `http://localhost:3000/show/season`, method: "GET", params, signal },
    options,
  );
};

export const getGetShowSeasonQueryKey = (params: GetShowSeasonParams) => {
  return [
    `http://localhost:3000/show/season`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetShowSeasonQueryOptions = <
  TData = Awaited<ReturnType<typeof getShowSeason>>,
  TError = ErrorType<unknown>,
>(
  params: GetShowSeasonParams,
  options?: {
    query?: Partial<
      SolidQueryOptions<
        Awaited<ReturnType<typeof getShowSeason>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetShowSeasonQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getShowSeason>>> = ({
    signal,
  }) => getShowSeason(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as SolidQueryOptions<
    Awaited<ReturnType<typeof getShowSeason>>,
    TError,
    TData
  > & { initialData?: undefined };
};

export type GetShowSeasonQueryResult = NonNullable<
  Awaited<ReturnType<typeof getShowSeason>>
>;
export type GetShowSeasonQueryError = ErrorType<unknown>;

export const createGetShowSeason = <
  TData = Awaited<ReturnType<typeof getShowSeason>>,
  TError = ErrorType<unknown>,
>(
  options: () => {
    params: GetShowSeasonParams;
    options?: {
      query?: Partial<
        SolidQueryOptions<
          Awaited<ReturnType<typeof getShowSeason>>,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customInstance>;
    };
  },
): CreateQueryResult<TData, TError> => {
  const query = createQuery(() => {
    const opts = options?.() || {};
    return getGetShowSeasonQueryOptions(opts["params"], opts["options"]);
  }) as CreateQueryResult<TData, TError>;

  return query;
};

/**
 * Get the informations of a episode
 */
export const getShowEpisode = (
  params: GetShowEpisodeParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<EpisodeDTO>(
    {
      url: `http://localhost:3000/show/episode`,
      method: "GET",
      params,
      signal,
    },
    options,
  );
};

export const getGetShowEpisodeQueryKey = (params: GetShowEpisodeParams) => {
  return [
    `http://localhost:3000/show/episode`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetShowEpisodeQueryOptions = <
  TData = Awaited<ReturnType<typeof getShowEpisode>>,
  TError = ErrorType<unknown>,
>(
  params: GetShowEpisodeParams,
  options?: {
    query?: Partial<
      SolidQueryOptions<
        Awaited<ReturnType<typeof getShowEpisode>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetShowEpisodeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getShowEpisode>>> = ({
    signal,
  }) => getShowEpisode(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as SolidQueryOptions<
    Awaited<ReturnType<typeof getShowEpisode>>,
    TError,
    TData
  > & { initialData?: undefined };
};

export type GetShowEpisodeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getShowEpisode>>
>;
export type GetShowEpisodeQueryError = ErrorType<unknown>;

export const createGetShowEpisode = <
  TData = Awaited<ReturnType<typeof getShowEpisode>>,
  TError = ErrorType<unknown>,
>(
  options: () => {
    params: GetShowEpisodeParams;
    options?: {
      query?: Partial<
        SolidQueryOptions<
          Awaited<ReturnType<typeof getShowEpisode>>,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customInstance>;
    };
  },
): CreateQueryResult<TData, TError> => {
  const query = createQuery(() => {
    const opts = options?.() || {};
    return getGetShowEpisodeQueryOptions(opts["params"], opts["options"]);
  }) as CreateQueryResult<TData, TError>;

  return query;
};
